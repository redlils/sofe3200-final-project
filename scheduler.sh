#! /bin/bash

# NOTE: REQUIRED PACKAGES:
# - mikefarah/yq
# - pcregrep

# Globals
script_name=$(basename "$0") # Use basename for if this script is being read through a symlink/a differenct directory
script_full_path=$(which scheduler || "$0")
version=$(git tag --points-at HEAD 2> /dev/null)+$(git rev-parse --short HEAD 2> /dev/null)
crontab_location="/etc/cron.d/scheduler_$USER"
crontab_shell="SHELL=/bin/bash"
crontab_path="PATH=$PATH"
crontab_header="# This file has been automatically generated by the 'scheduler' program.
# WARNING: If you don't know what you're doing, don't touch this file!"

# Colors
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)

# Styles
bold=$(tput bold)
reset=$(tput sgr0)

shopt -s extglob

# Verbose output
verbose=false

print_verbose() {
  if [ "$verbose" = true ]; then
    printf "[%s] %s\n" "$(date "+%Y-%m-%d %T")" "$1"
  fi
}

# Common outputs
print_help() {
  printf "%s\n" "Usage: $script_name [OPTION...] [COMMAND]

Commands:
  update                  update the active tasks defined in \$HOME/.config/scheduler
  run-workflow <name>     run the <name>.yml workflow in \$HOME/.config/scheduler
  list                    list all scheduled tasks

Options:
  -h, --help              show this help message
  -v, --verbose           display extra information while running
  -V, --version           display the version number"
}

print_invalid_option() {
  printf "%s\n\n" "$script_name: unknown option '$1'"
  print_usage_info
}

print_invalid_command() {
  printf "%s\n\n" "$script_name: unknown command '$1'"
  print_usage_info
}

print_usage_info() {
  printf "%s\n" "Use $script_name --help or refer to the man page for program usage information"
}

print_version() {
  echo "scheduler"
  echo "Author: Lily Redpath"
  echo "Version: $version"
}

# @param YAML path
# @param YAML file
test_yaml_for_value() {
  if yq "$1" "$2" | { ! grep "null"; } > /dev/null; then
    return 0
  fi
  return 1
}

# Helper methods
validate_workflow() {
  # is this file even here?
  if [ -f "$HOME/.config/scheduler/$1.yaml" ]; then
    return 1
  fi

  # Validate yaml schema
  # WARN: The workflow is *not* being parsed here! The yaml is 
  # solely being checked to see if the correct paths exist.
  #
  # INFO: schedule-workflow.yaml format
  # Schema (required paths start with a *):
  # *.schedule            Valid cron schedule format (validity is not checked upon registration)
  # *.tasks               List of tasks the workflow runner will run
  #   *.<task-name>       Definition of a new task to run
  #     .shell            Fully qualified path to a shell that will run this task (defaults to /bin/bash)
  #     .env              List of environment variables the workflow runner will use
  #       .<env-var>      KVP of an environment variable and it's associated value
  #     *.steps           List of shell commands the workflow runner will execute
  #       *.<step>        A shell command

  if ! test_yaml_for_value ".schedule"          "$1" ||
     ! test_yaml_for_value ".tasks"             "$1" ||
     ! test_yaml_for_value ".tasks.*"           "$1" ||
     ! test_yaml_for_value ".tasks.*.steps"     "$1" ||
     ! test_yaml_for_value ".tasks.*.steps[0]"  "$1" ;
  then
    return 1
  fi
  return 0
}

# Command handlers
update() {
  # Find our crontab
  if [ ! -f "$crontab_location" ]; then
    print_verbose "Unable to find crontab file, creating a new one..."
  fi

  print_verbose "Clearing old crontab via 'echo \$crontab_header > $crontab_location'"
  echo "${red}==>${reset}${bold} Clearing old scheduler crontab (requires authentication)${reset}"
  sudo -s crontab_shell="$crontab_shell"\
    crontab_path="$crontab_path"\
    crontab_header="$crontab_header"\
    crontab_location="$crontab_location" <<'END-OF-SUDO'
  echo $crontab_shell > $crontab_location
  echo $crontab_path >> $crontab_location
  echo $crontab_header >> $crontab_location
END-OF-SUDO

  print_verbose "Checking for configuration folder in \$HOME/.config/scheduler ($HOME/.config/scheduler)"

  if [ ! -d "$HOME"/.config/scheduler ]; then
    print_verbose "$HOME/.config/scheduler directory not found"
  print_verbose "Creating $HOME/.config/scheduler"
    mkdir -p "$HOME"/.config/scheduler
  else
    print_verbose "Found configuration directory"
  fi

  printf "%s\n" "${blue}==>${reset}${bold} Checking for valid .yaml files in $HOME/.config/scheduler${reset}"

  # Check to see if our config directory has no workflow files
  if ! grep -q ".*" "$HOME"/.config/scheduler/*.yaml 2> /dev/null; then
    printf "%s\n" "${bold}:: Workflow directory is empty!"
    exit 0 # Exit 0 is okay here because while the crontab was not updated, the program ran as expected.
  fi

  local added_workflows=()
  
  # Loop through our configuration files in $HOME/.config/scheduler and add them to the crontab
  for file in "$HOME"/.config/scheduler/*.yaml; do
    local schedule=""
    if yq "$file" > /dev/null; then
      print_verbose "Found valid .yaml file: $file"
      print_verbose "Checking schema..."
      
      if ! validate_workflow "$file"; then
        echo "${red}${bold}::${reset}${bold} Invalid workflow '$file'"
        continue
      fi

      echo "${green}${bold}::${reset}${bold} Found workflow '$file'${reset}"

      added_workflows+=("$file")

      schedule=$(yq ".schedule" "$file")

      # escalate to allow writing to /etc/cron.d/
      sudo -s schedule="$schedule" file="$file" crontab_location="$crontab_location" script_full_path="$script_full_path" <<'END-OF-SUDO'
      echo $(echo "$schedule" | tr --d '"') "$SUDO_USER $script_full_path -v run-workflow $(basename ${file%.*}) > /home/$SUDO_USER/scheduler.log" >> $crontab_location
END-OF-SUDO
      # de-escalate sudo permissions
      sudo -k
    else
      print_verbose "Invalid .yaml file '$file'"
    fi
  done

  printf "%s\n" "${bold}:: Successfully updated ${script_name} with all valid workflows."
}

workflow_stack=()

# @param Full workflow path
# @param Current task
get_dependencies() {
  readarray -t depends < <(yq ".tasks.$2.depends-on.[] | @sh" "$1")
  print_verbose "depend-on for $2: \"${depends[*]}\" (${#depends[@]})"
  if printf "%s\0" "${workflow_stack[@]}" | grep -Fxz -- "$2" > /dev/null; then
    return 0;
  else
    workflow_stack=("$2" "${workflow_stack[@]}")
  fi
  if [[ ${#depends[@]} -gt 0 ]]; then
    for dependency in "${depends[@]}"; do
      get_dependencies "$1" "$dependency"
    done
  fi
}

# TODO: man.
run_workflow() {
  local full_workflow_path="$HOME/.config/scheduler/$1.yaml"

  # Check to see if the workflow even exists in the first place
  if [ ! -e "$full_workflow_path" ]; then
    printf "%s\n" "${bold}${red}==>${reset}${bold} Workflow '$1' ($full_workflow_path) does not exist on disk!"
    exit 2
  fi
  
  # Validate the workflow that's being run to ensure it's a valid workflow.
  printf "%s\n" "${bold}${blue}==>${reset}${bold} Validating workflow '$1' ($full_workflow_path)"
  if ! validate_workflow "$HOME/.config/scheduler/$1.yaml"; then
    printf "%s\n" "${bold}${red}::${reset}${bold} Invalid workflow '$1'!"
    exit 2
  fi

  # The workflow's **schema** has been validated by this point
  # NOTE: The actual commands may potentially be invalid, but we as the scheduler program don't care about the user's command mistakes.
  
  # Setup list of tasks
  readarray -t tasks < <(yq '.tasks.[] | path | omit([0]) | join("") | @sh' "$full_workflow_path")

  # Create workflow stack to define running order of tasks
  # Using workflow_stack variable as bash can't return anything except a number between 0-255.........
  printf "%s\n" "${bold}${blue}==>${reset}${bold} Determining task execution order...${reset}"
  for task in "${tasks[@]}"; do
    get_dependencies "$full_workflow_path" "$task"
  done
  printf "%s\n" "${bold}${green}==>${reset}${bold} Determined execution order:${reset}"
  for task in "${workflow_stack[@]}"; do
    printf "    %s\n" "${bold}$task${reset}"
  done

  # It's time to run the workflows!
  for task in "${workflow_stack[@]}"; do
    printf "%s\n" "${blue}${bold}==>${reset}${bold} Starting '$task'...${reset}"

    # Get environment variables from '.env'
    if test_yaml_for_value ".tasks.$task.env" "$full_workflow_path"; then
      printf "%s\n" "${bold}:: Loading environment variables from 'env'...${reset}"
      readarray -t envs < <(yq ".tasks.$task.env | keys | join(\"\n\")" "$full_workflow_path")
      for env in "${envs[@]}"; do
        declare "$env"="$(yq ".tasks.$task.env.$env" "$full_workflow_path")"
        printf "%s\n" "${bold}Set environment variable '$env'=${!env}${reset}"
      done
    fi
    
    # Run the steps!
    readarray -t steps < <(yq ".tasks.$task.steps.[]" "$full_workflow_path")
    for step in "${steps[@]}"; do
      printf "%s\n" "${bold}:: Running '$step'${reset}"
      eval "$step"
    done
  done
}

list() {
  readarray -t registered_entries < <(pcregrep -M -o1 "$script_name -v run-workflow (\w*\.yaml)" "$crontab_location")
  echo "${bold}Registered entries in $crontab_location:${reset}"
  for reg_entry in "${registered_entries[@]}"
  do
    echo "${bold}:: ${reset}$reg_entry"
  done
}

main() {
  if [ "$EUID" -eq 0 ]; then
    printf "%s\n" "${yellow}==>${reset}${bold} Warning: running $script_name as the root user should generally be avoided!${reset}"
  fi

  if [ $# -eq 0 ]; then
    printf "%s\n\n" "$script_name: need 'update', 'run-workflow', or 'list'" 1>&2
    print_usage_info 1>&2
    exit 1
  fi

  local prepared_commands=()
  local workflow=""

  # Parse arguments
  while (( $# > 0 )); do
    case $1 in
      # options
      -h|--help)      print_help; exit 0 ;;
      -v|--verbose)   verbose=true ;;
      -V|--version)   print_version; exit 0 ;;
      -*)             print_invalid_option "$1"; exit 1 ;;

      # commands
      list)           prepared_commands+=("list") ;;
      run-workflow)   prepared_commands+=("run-workflow"); workflow=( "${2?$script_name run-workflow: expected argument <name>}" ); shift ;;
      update)         prepared_commands+=("update") ;;
      *)              print_invalid_command "$1"; exit 1 ;;
    esac
    shift
  done

  if [ "${#prepared_commands[@]}" -gt 1 ] || [ "${#prepared_commands[@]}" -eq 0 ]; then
    echo uh oh!
    exit 1
  fi

  command=${prepared_commands[0]}
  case $command in
    list)           list ;;
    run-workflow)   run_workflow "${workflow[0]}" ;;
    update)         update ;;
    *)              echo "how the fluff did we get here" ;;
  esac

  exit 0
}

main "$@"
