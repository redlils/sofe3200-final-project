#! /bin/bash

# NOTE: REQUIRED PACKAGES:
# - yq

# Globals
script_name=$(basename "$0") # Use basename for if this script is being read through a symlink/a differenct directory
version=$(git tag --points-at HEAD)+$(git rev-parse --short HEAD)
crontab_location="/etc/cron.d/scheduler"
crontab_header="# This file has been automatically generated by the 'scheduler' program.
# WARNING: If you don't know what you're doing, don't touch this file!"

# TODO: Actually create a --verbose option to toggle this properly!
verbose=false

print_verbose() {
  if [ "$verbose" = true ]; then
    printf "[%s] %s\n" "$(date "+%Y-%m-%d %T")" "$1"
  fi
}

# Functions
print_help() {
  printf "%s\n" "Usage: $script_name [OPTION...] [COMMAND]

Commands:
  update                  update the active tasks defined in \$HOME/.config/scheduler
  run-workflow <name>     run the <name>.yml workflow in \$HOME/.config/scheduler
  list                    list all scheduled tasks

Options:
  -h, --help              show this help message
  -v, --verbose           display extra information while running
  -V, --version           display the version number"
}

print_invalid_option() {
  printf "%s\n\n" "$script_name: unknown option '$1'"
  print_usage_info
}

print_usage_info() {
  printf "%s\n" "Use $script_name --help or refer to the man page for program usage information"
}

print_version() {
  echo "scheduler"
  echo "Author: Lily Redpath"
  echo "Version: $version"
}

# Command handlers
update() {
  # Find our crontab
  if [ ! -f "$crontab_location" ]; then
    print_verbose "Unable to find crontab file, creating a new one..."
  fi

  print_verbose "Clearing old crontab via 'echo \$crontab_header > /etc/cron.d/scheduler'"
  sudo -s crontab_header="$crontab_header" crontab_location="$crontab_location" <<'END-OF-SUDO'
  echo $crontab_header > $crontab_location
END-OF-SUDO

  print_verbose "Checking for configuration folder in \$HOME/.config/scheduler ($HOME/.config/scheduler)"

  if [ ! -d "$HOME"/.config/scheduler ]; then
    print_verbose "$HOME/.config/scheduler directory not found"
    print_verbose "Creating $HOME/.config/scheduler"
    mkdir -p "$HOME"/.config/scheduler
  else
    print_verbose "Found configuration directory"
  fi

  print_verbose "Searching for valid .yml files in $HOME/.config/scheduler"
  # Loop through our configuration files in $HOME/.config/scheduler and add them to the crontab
  for file in "$HOME"/.config/scheduler/*.yaml; do
    local schedule=""
    if yq ".schedule" "$file"; then
      schedule=$(yq ".schedule" "$file")

      # escalate to allow writing to /etc/cron.d/
      sudo -s schedule="$schedule" file="$file" crontab_location="$crontab_location" <<'END-OF-SUDO'
      echo $(echo "$schedule" | tr --d '"') "$SUDO_USER" scheduler run-workflow "$(basename "$file" ".yaml") >> $crontab_location
END-OF-SUDO
      # de-escalate sudo permissions
      sudo -k
    else
      print_verbose "Invalid .yaml file '$file'"
    fi
  done
}

run_workflow() {
  echo "run_workflow"
}

list() {
 echo "list"
}

main() {
  if [ $# -eq 0 ]; then
    printf "%s\n\n" "$script_name: need 'update', 'run-workflow', or 'list'" 1>&2
    print_usage_info 1>&2
    exit 1
  fi

  # Attempt to locate and parse options
  for arg in "$@"; do
    if [[ "$arg" == --* ]]; then
      # We have a potential long option!
      # Time to check them!
      if [ "$arg" == "--help" ]; then
        print_help
        exit 0
      elif [ "$arg" == "--verbose" ]; then
        verbose=true
        continue
      elif [ "$arg" == "--version" ]; then
        print_version
        exit 0
      fi

      # If we were unable to parse this long option, this must not be a valid option
      print_invalid_option "$arg"
      exit 1
    # Attempt to parse out boolean short options
    # WARN: This should be the last check run!
    elif [[ "$arg" == -* ]]; then
      local found_bool_option=false
      if [[ "$arg" == *h* ]]; then
        print_help
        exit 0
      fi
      if [[ "$arg" == *v* ]]; then
        verbose=true
        found_bool_option=true
      fi
      if [[ "$arg" == *V* ]]; then
        print_version
        exit 0
      fi

      # If we're unable to find a boolean option out of this then this must not be a valid option!
      if [ "$found_bool_option" == "false" ]; then
        print_invalid_option "$arg"
        exit 1
      fi
    fi
  done

  # Handle arguments
  if [ "$1" = "update" ]; then
    print_verbose "Running scheduler update..."
    update
  elif [ "$1" = "remove" ]; then
    if [ $# -lt 2 ]; then
      printf "%s" "$script_name: remove needs <name>\n\n" 1>&2
      print_usage_info 1>&2
      exit 1
    fi
    remove-task
  else
    echo ":3"
  fi
}

main "$@"
