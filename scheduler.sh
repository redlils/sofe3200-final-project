#! /bin/bash

# NOTE: REQUIRED PACKAGES:
# - mikefarah/yq
# - pcregrep

# Globals
script_name=$(basename "$0") # Use basename for if this script is being read through a symlink/a differenct directory
script_full_path=$(which scheduler || "$0")
version=$(git tag --points-at HEAD 2> /dev/null)+$(git rev-parse --short HEAD 2> /dev/null)
crontab_location="/etc/cron.d/scheduler"
crontab_shell="SHELL=/bin/bash"
crontab_path="PATH=$PATH"
crontab_header="# This file has been automatically generated by the 'scheduler' program.
# WARNING: If you don't know what you're doing, don't touch this file!"

# Colors
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)

# Styles
bold=$(tput bold)
reset=$(tput sgr0)

shopt -s extglob

# Verbose output
verbose=false

print_verbose() {
  if [ "$verbose" = true ]; then
    printf "[%s] %s\n" "$(date "+%Y-%m-%d %T")" "$1"
  fi
}

# Common outputs
print_help() {
  printf "%s\n" "Usage: $script_name [OPTION...] [COMMAND]

Commands:
  update                  update the active tasks defined in \$HOME/.config/scheduler
  run-workflow <name>     run the <name>.yml workflow in \$HOME/.config/scheduler
  list                    list all scheduled tasks

Options:
  -h, --help              show this help message
  -v, --verbose           display extra information while running
  -V, --version           display the version number"
}

print_invalid_option() {
  printf "%s\n\n" "$script_name: unknown option '$1'"
  print_usage_info
}

print_invalid_command() {
  printf "%s\n\n" "$script_name: unknown command '$1'"
  print_usage_info
}

print_usage_info() {
  printf "%s\n" "Use $script_name --help or refer to the man page for program usage information"
}

print_version() {
  echo "scheduler"
  echo "Author: Lily Redpath"
  echo "Version: $version"
}

# Helper methods
validate_workflow() {
    # Validate yaml schema
    # WARN: The workflow is *not* being parsed here! The yaml is 
    # solely being checked to see if the correct paths exist.
    #
    # INFO: schedule-workflow.yaml format
    # Schema (required paths start with a *):
    # *.schedule            Valid cron schedule format (validity is not checked upon registration)
    # *.tasks               List of tasks the workflow runner will run
    #   *.<task-name>       Definition of a new task to run
    #     .shell            Fully qualified path to a shell that will run this task (defaults to /bin/bash)
    #     .env              List of environment variables the workflow runner will use
    #       .<env-var>      KVP of an environment variable and it's associated value
    #     *.steps           List of shell commands the workflow runner will execute
    #       *.<step>        A shell command

    if  ! yq ".schedule"          "$1"  | { ! grep "null"; } > /dev/null || # Check ".schedule" exists
        ! yq ".tasks"             "$1"  | { ! grep "null"; } > /dev/null || # Check ".tasks" exists
        ! yq ".tasks.*"           "$1"  | { ! grep "null"; } > /dev/null || # Check there's at least 1 task specified
        ! yq ".tasks.*.steps"     "$1"  | { ! grep "null"; } > /dev/null || # Check that the task has a steps section
        ! yq ".tasks.*.steps[0]"  "$1"  | { ! grep "null"; } > /dev/null ;  # Check that the task has at least 1 step
    then
      return 1
    fi
    return 0
}

# Command handlers
update() {
  # Find our crontab
  if [ ! -f "$crontab_location" ]; then
    print_verbose "Unable to find crontab file, creating a new one..."
  fi

  print_verbose "Clearing old crontab via 'echo \$crontab_header > /etc/cron.d/scheduler'"
  echo "${red}==>${reset}${bold} Clearing old scheduler crontab (requires authentication)${reset}"
  sudo -s crontab_shell="$crontab_shell"\
    crontab_path="$crontab_path"\
    crontab_header="$crontab_header"\
    crontab_location="$crontab_location" <<'END-OF-SUDO'
  echo $crontab_shell > $crontab_location
  echo $crontab_path >> $crontab_location
  echo $crontab_header >> $crontab_location
END-OF-SUDO

  print_verbose "Checking for configuration folder in \$HOME/.config/scheduler ($HOME/.config/scheduler)"

  if [ ! -d "$HOME"/.config/scheduler ]; then
    print_verbose "$HOME/.config/scheduler directory not found"
    print_verbose "Creating $HOME/.config/scheduler"
    mkdir -p "$HOME"/.config/scheduler
  else
    print_verbose "Found configuration directory"
  fi

  printf "%s\n" "${blue}==>${reset}${bold} Checking for valid .yaml files in $HOME/.config/scheduler${reset}"

  # Check to see if our config directory has no workflow files
  if ! grep -q ".*" "$HOME"/.config/scheduler/*.yaml 2> /dev/null; then
    printf "%s\n" "${bold}:: Workflow directory is empty!"
    exit 0 # Exit 0 is okay here because while the crontab was not updated, the program ran as expected.
  fi

  # Loop through our configuration files in $HOME/.config/scheduler and add them to the crontab
  for file in "$HOME"/.config/scheduler/*.yaml; do
    local schedule=""
    if yq "$file" > /dev/null; then
      print_verbose "Found valid .yaml file: $file"
      print_verbose "Checking schema..."
      
      if ! validate_workflow "$file"; then
        echo "${red}${bold}::${reset}${bold} Invalid workflow '$file'"
        continue
      fi

      echo "${green}${bold}::${reset}${bold} Found workflow '$file'${reset}"

      schedule=$(yq ".schedule" "$file")

      # escalate to allow writing to /etc/cron.d/
      sudo -s schedule="$schedule" file="$file" crontab_location="$crontab_location" script_full_path="$script_full_path" <<'END-OF-SUDO'
      echo $(echo "$schedule" | tr --d '"') "$SUDO_USER $script_full_path -v run-workflow $(basename $file) > /home/$SUDO_USER/scheduler.log" >> $crontab_location
END-OF-SUDO
      # de-escalate sudo permissions
      sudo -k
    else
      print_verbose "Invalid .yaml file '$file'"
    fi
  done
}

run_workflow() {
  echo "run_workflow"
  notify-send "bark"
}

list() {
  mapfile -t registered_entries < <(pcregrep -M -o1 "$script_name -v run-workflow (\w*\.yaml)" "$crontab_location")
  echo "${bold}Registered entries in $crontab_location:${reset}"
  for reg_entry in "${registered_entries[@]}"
  do
    echo "${bold}:: ${reset}$reg_entry"
  done
}

main() {
  if [ "$EUID" -eq 0 ]; then
    printf "%s\n" "${yellow}==>${reset}${bold} Warning: running $script_name as the root user should generally be avoided!${reset}"
  fi

  if [ $# -eq 0 ]; then
    printf "%s\n\n" "$script_name: need 'update', 'run-workflow', or 'list'" 1>&2
    print_usage_info 1>&2
    exit 1
  fi

  local prepared_commands=()
  local workflow=""

  # Parse arguments
  while (( $# > 0 )); do
    case $1 in
      # options
      -h|--help)      print_help; exit 0 ;;
      -v|--verbose)   verbose=true ;;
      -V|--version)   print_version; exit 0 ;;
      -*)             print_invalid_option "$1"; exit 1 ;;

      # commands
      list)           prepared_commands+=("list") ;;
      run-workflow)   prepared_commands+=("run-workflow"); workflow=( "${2?$script_name run-workflow: expected argument <name>}" ); shift ;;
      update)         prepared_commands+=("update") ;;
      *)              print_invalid_command "$1"; exit 1 ;;
    esac
    shift
  done

  if [ "${#prepared_commands[@]}" -gt 1 ] || [ "${#prepared_commands[@]}" -eq 0 ]; then
    echo uh oh!
    exit 1
  fi

  command=${prepared_commands[0]}
  case $command in
    list)           list ;;
    run-workflow)   run_workflow "${workflow[0]}" ;;
    update)         update ;;
    *)              echo "how the fluff did we get here" ;;
  esac

  exit 0
}

main "$@"
