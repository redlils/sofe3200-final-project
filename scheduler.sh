#! /bin/bash

# NOTE: REQUIRED PACKAGES:
# - yq

# Globals
script_name=$(basename "$0") # Use basename for if this script is being read through a symlink/a differenct directory
script_full_path=$(which scheduler || "$0")
version=$(git tag --points-at HEAD)+$(git rev-parse --short HEAD)
crontab_location="/etc/cron.d/scheduler"
crontab_shell="SHELL=/bin/bash"
crontab_path="PATH=$PATH"
crontab_header="# This file has been automatically generated by the 'scheduler' program.
# WARNING: If you don't know what you're doing, don't touch this file!"

shopt -s extglob

# TODO: Actually create a --verbose option to toggle this properly!
verbose=false

print_verbose() {
  if [ "$verbose" = true ]; then
    printf "[%s] %s\n" "$(date "+%Y-%m-%d %T")" "$1"
  fi
}

# Functions
print_help() {
  printf "%s\n" "Usage: $script_name [OPTION...] [COMMAND]

Commands:
  update                  update the active tasks defined in \$HOME/.config/scheduler
  run-workflow <name>     run the <name>.yml workflow in \$HOME/.config/scheduler
  list                    list all scheduled tasks

Options:
  -h, --help              show this help message
  -v, --verbose           display extra information while running
  -V, --version           display the version number"
}

print_invalid_option() {
  printf "%s\n\n" "$script_name: unknown option '$1'"
  print_usage_info
}

print_invalid_command() {
  printf "%s\n\n" "$script_name: unknown command '$1'"
  print_usage_info
}

print_usage_info() {
  printf "%s\n" "Use $script_name --help or refer to the man page for program usage information"
}

print_version() {
  echo "scheduler"
  echo "Author: Lily Redpath"
  echo "Version: $version"
}

# Command handlers
update() {
  # Find our crontab
  if [ ! -f "$crontab_location" ]; then
    print_verbose "Unable to find crontab file, creating a new one..."
  fi

  print_verbose "Clearing old crontab via 'echo \$crontab_header > /etc/cron.d/scheduler'"
  echo "==> Clearing old scheduler crontab (requires authentication)"
  sudo -s crontab_shell="$crontab_shell"\
    crontab_path="$crontab_path"\
    crontab_header="$crontab_header"\
    crontab_location="$crontab_location" <<'END-OF-SUDO'
  echo $crontab_shell > $crontab_location
  echo $crontab_path >> $crontab_location
  echo $crontab_header >> $crontab_location
END-OF-SUDO

  print_verbose "Checking for configuration folder in \$HOME/.config/scheduler ($HOME/.config/scheduler)"

  if [ ! -d "$HOME"/.config/scheduler ]; then
    print_verbose "$HOME/.config/scheduler directory not found"
    print_verbose "Creating $HOME/.config/scheduler"
    mkdir -p "$HOME"/.config/scheduler
  else
    print_verbose "Found configuration directory"
  fi

  print_verbose "Searching for valid .yml files in $HOME/.config/scheduler"
  
  # Loop through our configuration files in $HOME/.config/scheduler and add them to the crontab
  for file in "$HOME"/.config/scheduler/*.yaml; do
    local schedule=""
    if yq ".schedule" "$file"; then
      print_verbose "Found valid file: $file"
      schedule=$(yq ".schedule" "$file")

      # escalate to allow writing to /etc/cron.d/
      sudo -s schedule="$schedule" file="$file" crontab_location="$crontab_location" script_full_path="$script_full_path" <<'END-OF-SUDO'
      echo $(echo "$schedule" | tr --d '"') "$SUDO_USER $script_full_path -v run-workflow $(basename $file) > /home/$SUDO_USER/scheduler.log" >> $crontab_location
END-OF-SUDO
      # de-escalate sudo permissions
      sudo -k
    else
      print_verbose "Invalid .yaml file '$file'"
    fi
  done
}

run_workflow() {
  echo "run_workflow"
  notify-send "bark"
}

list() {
 echo "list"
}

main() {
  if [ $# -eq 0 ]; then
    printf "%s\n\n" "$script_name: need 'update', 'run-workflow', or 'list'" 1>&2
    print_usage_info 1>&2
    exit 1
  fi

  local prepared_commands=()
  local workflow=""

  # Parse arguments
  while (( $# > 0 )); do
    case $1 in
      # options
      -h|--help)      print_help; exit 0 ;;
      -v|--verbose)   verbose=true ;;
      -V|--version)   print_version; exit 0 ;;
      -*)             print_invalid_option "$1"; exit 1 ;;

      # commands
      list)           prepared_commands+=("list") ;;
      run-workflow)   prepared_commands+=("run-workflow"); workflow=( "${2?$script_name run-workflow: expected argument <name>}" ); shift ;;
      update)         prepared_commands+=("update") ;;
      *)              print_invalid_command "$1"; exit 1 ;;
    esac
    shift
  done

  if [ "${#prepared_commands[@]}" -gt 1 ]; then
    echo uh oh!
    exit 1
  fi

  command=${prepared_commands[0]}
  case $command in
    list)           echo ":3" ;;
    run-workflow)   run_workflow ;;
    update)         update ;;
    *)              echo "how the fluff did we get here" ;;
  esac

  exit 0
}

main "$@"
